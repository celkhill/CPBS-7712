import numpy as np
import pandas as pd
from os import path, makedirs
import pdb
from FileIOUtils import ReadFasta, SaveTableToFile
from DeBruijnGraph import GraphNode


def CreateKmersFromReads(reads, kmersize):
    kmers = []
    for read in reads.values():
        idx = 0;
        for idx in range(len(read)-(kmersize-1)):
            #don't care about dupes, just want a list of all k-1 mers
            kmers += [read[idx:kmersize+idx]]
    return kmers


def GetReverseComplement(seq, pairing_dict={'G':'C','C':'G','A':'T','T':'A'}):
    new_seq = ''
    for s in seq[::-1]:
        if s in pairing_dict:
            new_seq += pairing_dict[s]
        else:
            print('Letter not found in alphabet!')
    return new_seq

def CreateDBGraph(kmer_table, kmersize):
    """
    Function to generate a De Bruijn Graph and save it to a file.
    Inputs:
        reads: A dictionary of reads as generated by ParseReads.
        kmersize: An int value to use as the kmersize in the graph.
        outname: The filename to save the graph to.
    Output:
        The constructed node_table as a dictionary with nodes of k-1 mer and edges connecting them.
    """
    
    print('Creating graph with the following attributes:\n\t# of kmers: %d\n\tkmersize: %d\n\n'%(len(kmer_table),kmersize))
    node_table = {}
    #read and parse all our k-mers
    for direction in ['forward','reverse']:
        for kmer in kmer_table:
            #account for the reverse direction!
            if direction == 'reverse':
                kmer_degree = kmer_table[kmer]
                kmer = GetReverseComplement(kmer)
            else:
                kmer_degree = kmer_table[kmer]

            kmer_1 = kmer[:-1]
            kmer_2 = kmer[1:]
            #draw all our edges!
            if kmer_1 in node_table:
                currentNode = node_table[kmer_1]
            else:
                currentNode = GraphNode(seq = kmer_1)
            #add our next node
            currentNode.append_to_next(kmer[-1],count=kmer_degree)
            #add the previous node!
            if kmer_2 in node_table:
                nextNode = node_table[kmer_2]
            else:
                nextNode = GraphNode(seq = kmer_2)
            nextNode.append_to_prev(kmer[0],count=kmer_degree)
    
            #update them in our node table!
            node_table[kmer_1] = currentNode
            node_table[kmer_2] = nextNode
    return node_table

def GetHammingDistance(string1,string2):
    return np.sum([int(x!=y) for x,y in zip(string1,string2)])

def CorrectErrors(kmer_table):
    #find the degree of each node in the table
    low_degree_nodes = []
    threshold = 2
    seq_loop = 0
    for seq in kmer_table:
        seq_loop+=1
        # find where these are less than or equal to the threshold
        if kmer_table[seq] <= threshold:
            low_degree_nodes+=[seq]
            corrected_kmer = FindCorrectedKmer(seq,kmer_table)
            if corrected_kmer is not None:
                kmer_table[corrected_kmer] += kmer_table[seq]
    for seq in low_degree_nodes:
        #delete the node from our table
        del kmer_table[seq]
    return kmer_table

def FindCorrectedKmer(seq, kmer_table, threshold = 4, alphabet = ['G','C','A','T']):
    for idx in range(len(seq)-1,0,-1):
        options = [seq[0:idx] + a + seq[idx+1:] for a in alphabet]
        found_options = [o for o in options if o in kmer_table]
        found_options_better_than_thresh = np.where(np.array([kmer_table[x] for x in found_options])> threshold)[0]
        if len(found_options_better_than_thresh) > 0:
            #randomly correct here
            corrected_kmer = found_options[np.random.choice(found_options_better_than_thresh)]
            kmer_table[corrected_kmer] += kmer_table[seq]
            keep_looping = False
    #no fix found...
    return None

def GenerateHistograms(reads, kmer_table,output_folder):
    if not path.isdir(output_folder):
        makedirs(output_folder)
    #now let's make some histogram data!
    #read length histograms
    read_lengths = [len(x) for x in reads.values()]
    pd.DataFrame(np.histogram(read_lengths,bins=1000),index=['Counts','Lengths']).T.to_csv(path.join(output_folder,'ReadLengthHistogram.csv'),index=False)
    #kmer histograms
    kmer_degrees = [x for x in kmer_table.values()]
    pd.DataFrame(np.histogram(kmer_degrees,bins=1000),index=['Counts','Degree']).T.to_csv(path.join(output_folder,'KmerDegreeHistogram.csv'),index=False)

def CreateDeBruijnGraphAndSave(reads_fasta, kmersize, de_bruijn_graph_filename, existing_kmer_table = None, do_error_correction = True, generate_histograms = False, save_kmer_table = True):
    reads = ReadFasta(reads_fasta)
    smallest_read_length = np.min([len(r) for r in reads.values()])

    if kmersize > smallest_read_length:
        raise ValueError('Chosen kmer size is larger than the smallest read. Please lower the kmer size to at most %d'%smallest_read_length)

    if existing_kmer_table is not None:
        kmer_table = LoadTableFromFile(existing_kmer_table)
    else:
        kmers = CreateKmersFromReads(reads,kmersize)
        
        kmers_un, degrees = np.unique(kmers,return_counts = True)
        kmer_table = dict(zip(kmers_un, degrees))
        if do_error_correction is True:
            print('Correcting errors in kmers...')
            kmer_table = CorrectErrors(kmer_table)
        
        if save_kmer_table is True:
            ext = path.splitext(de_bruijn_graph_filename)[-1]
            kmer_table_path = path.join(path.dirname(de_bruijn_graph_filename),'kmer_table_%s.%s'%('corrected' if do_error_correction else 'uncorrected',ext))
            SaveTableToFile(kmer_table, kmer_table_path)
            print('Successfully wrote kmer table to file: %s'%kmer_table_path)

    if generate_histograms:
        GenerateHistograms(reads, kmer_table, path.dirname(de_bruijn_graph_filename))
        
    # now let's construct the graph from the table!
    node_table = CreateDBGraph(kmer_table, kmersize)
    SaveTableToFile(node_table, de_bruijn_graph_filename)
    print('\nDone creating graph!\nSuccessfully saved to file %s'%de_bruijn_graph_filename)

    return node_table
